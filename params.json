{"name":"app-link","tagline":"","body":"App 接入指南\r\n================\r\n\r\n文档中, App表示客户端,Server表示服务器端\r\n\r\n接入步骤\r\n----------------\r\n1. 启动App  \r\n2. App本地判断是否已经在`Server`端注册过, 如果没有注册过,则`Server`返回一个`appid`和`appsecret`作为身份和加密串,如果无特殊说明`App`每次请求`Server`都必须带上这个`appid`作为身份标识,另外还必须传输`timestamp`时间戳参数作为动态签名用,每次请求`Server`都将带有`sign`签名参数,`Server`根据`sign`来判断此`App`请求是否合法。\r\n\r\n`Sign`签名参数生成规则:  \r\n将所传递参数的key根据字典排序,然后将`key`和`value`字符串想加起来,将最终的字符串`md5`哈希得到`sign`签名  \r\n\r\n请求示例\r\n----------------\r\n\r\n例如用户`post`登录接口,参数如下：\r\n\r\n    mobile=13333333333&password=123456&appid=123456&timestamp=123456\r\n\r\n1.先根据字典将`key`排序,`appid,mobile,password,timestamp`\r\n\r\n2.拼接字符串\r\n\r\n    string str =\r\n    \"appid123456\"+\"mobile1333333333\"+\"password123456\"+\"timestamp123456\"+appsecret\r\n\r\n3.对生成的`str`进行`md5`哈希`string sign = md5(str)`\r\n\r\n4.将`sign`参数作为签名参数传给`Server`,`Server`获取到所有参数,将sign签名排除之后用同样的方法声称`sign`来验证。如果合法则继续操作流程,测试环境可暂时不加这个限制,但是功能要预留。\r\n\r\n5.签名时的中文需要使用`utf-8`进行`urlencode`,`signature`验证签名生成方式修改为\r\n\r\n    md5(appid+appsecret+timestamp) //这里注意把MD5值设置为大写\r\n\r\n6.`http`接口如不特殊说明,都表示`App`向`Server`请求,如不特殊说明,请求都将带有`sign`,`appid`和`timestamp`。\r\n\r\n6.1、如果获取失败,响应格式为：\r\n```json\r\n    {\r\n    \"status\":\"fail\",\r\n    \"code\":1001,\r\n    \"result\":\"数据库连接失败\"\r\n    }\r\n```\r\n\r\n6.2、如果获取成功,响应格式为：\r\n```json\r\n    {\r\n     \"status\":\"success\",\r\n     \"code\":200,\r\n     \"result\":\"{data}\" //不同接口返回的data不同\r\n    }\r\n```\r\n\r\n特别说明\r\n----------------\r\n\r\n后续文档中的返回值都表示响应成功里的`result`属性值,如没有特殊说明,接口写到的参数都为必传,并且都需要`sign`签名和`appid`。\r\n所有接口中传递的参数,请求`url`地址和返回值的`key`都约定为纯小写。","google":"UA-4316341-3","note":"Don't delete this file! It's used internally to help with page regeneration."}